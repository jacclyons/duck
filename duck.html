<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>duck</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#0b1020; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: rgba(255,255,255,0.92);
      background: #181818;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
      max-width: 420px;
      line-height: 1.25;
      user-select: none;
      display: none; /* shown only when online */
    }
    #hud.online { display: block; }
    #hud b { display:block; margin-bottom: 6px; }
    #crosshair {
      position: fixed; left:50%; top:50%; transform: translate(-50%, -50%);
      width: 14px; height: 14px; z-index: 9; pointer-events:none;
      opacity: 0.85;
    }
    #crosshair:before, #crosshair:after {
      content:""; position:absolute; left:50%; top:50%;
      background: rgba(255,255,255,0.9);
      transform: translate(-50%, -50%);
      border-radius: 2px;
    }
    #crosshair:before { width: 14px; height: 2px; }
    #crosshair:after  { width: 2px; height: 14px; }
    #chargeBar {
      position: fixed; left: 50%; bottom: 60px; transform: translateX(-50%);
      width: 120px; height: 8px;
      background: #181818;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 6px;
      z-index: 10;
      overflow: hidden;
      opacity: 0;
      transition: opacity 0.15s;
    }
    #chargeBar.visible { opacity: 1; }
    #chargeFill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #476af5, #71cbfb, #44efbf);
      border-radius: 6px;
      transition: width 0.05s linear;
    }
    #hint {
      position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%);
      color: rgba(255,255,255,0.9);
      background: #181818;
      border-radius: 1000px;
      padding: 8px 14px;
      z-index: 10;
      user-select:none;
      white-space: nowrap;
    }
    #menu {
      position: fixed; inset: 0; z-index: 20;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      background: #181818;
      color: rgba(255,255,255,0.95);
      text-align: center;
      padding: 24px;
    }
    #menu.hidden { display: none; }
    #menu .card {
      max-width: 480px;
      background: #181818;
      border-radius: 20px;
      padding: 32px 36px;
      backdrop-filter: blur(12px);
    }
    #menu h1 { margin: 0 0 8px; font-size: 1.75rem; }
    #menu .menu-logo { display: block; max-width: 100%; height: auto; max-height: 6rem; margin: 0 auto 12px; }
    #menu .subtitle { opacity: 0.9; font-size: 0.95rem; margin-bottom: 28px; }
    #menu .playBtn {
      display: block; width: 100%;
      border: 1px solid transparent; border-radius: 14px;
      padding: 16px 24px;
      background: #FFBE00;
      color: #181818;
      font-size: 1.15rem; font-weight: 700;
      cursor: pointer;
    }
    #menu .playBtn:hover {
      border-color: #FFBE00;
    }
    #menu .controls {
      font-size: 0.85rem;
      line-height: 1.8;
      color: rgba(255,255,255,0.8);
    }
    #menu .controls kbd {
      display: inline-block;
      padding: 0.15em 0.45em;
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.75em;
      font-weight: 600;
      line-height: 1;
      color: rgba(255,255,255,0.95);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 0.35em;
      box-shadow: 0 1px 0 rgba(0,0,0,0.3);
      margin: 0 0.1em;
    }
    #menu .controls .sep {
      color: rgba(255,255,255,0.4);
      margin: 0 0.35em;
      font-weight: 400;
    }
    #menu .controls-dropdown {
      margin-top: 16px;
      overflow: hidden;
    }
    #menu .controls-dropdown summary {
      padding: 10px 14px;
      font-size: 0.9rem;
      color: rgba(255,255,255,0.75);
      cursor: pointer;
      list-style: none;
      user-select: none;
    }
    #menu .controls-dropdown summary::-webkit-details-marker { display: none; }
    #menu .controls-dropdown summary::after {
      content: "▾";
      float: right;
      opacity: 0.6;
      transition: transform 0.2s;
    }
    #menu .controls-dropdown[open] summary::after { transform: rotate(180deg); }
    #menu .controls-dropdown .controls-inner {
      padding: 12px 14px 14px;
      background: #181818;
    }
    #menu .status { margin-top: 16px; font-size: 0.9rem; opacity: 0.8; }
    /* Pause overlay (blurred background) + sidebar */
    #pauseOverlay {
      position: fixed; inset: 0; z-index: 25;
      display: none;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #pauseOverlay.visible { display: block; }
    #pauseSidebar {
      position: absolute; right: 0; top: 0; bottom: 0;
      width: 260px;
      background: #181818;
      border-left: 1px solid rgba(255,255,255,0.12);
      padding: 28px 24px;
      box-shadow: -8px 0 32px rgba(0,0,0,0.4);
      display: flex; flex-direction: column; gap: 20px;
    }
    #pauseSidebar h2 {
      margin: 0; font-size: 1.1rem; font-weight: 600;
      color: rgba(255,255,255,0.95);
    }
    #pauseSidebar .pauseBtn {
      display: block; width: 100%;
      padding: 14px 20px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      font-size: 1rem; font-weight: 700;
      cursor: pointer;
      background: rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.95);
    }
    #pauseSidebar .pauseBtn:hover { filter: brightness(1.1); }
    #pauseSidebar .pauseBtnPrimary {
      background: #FFBE00;
      color: #181818;
      border-color: transparent;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="menu">
    <div class="card">
      <img src="duck.svg" alt="duck" class="menu-logo" />
      <button id="createGameBtn" class="playBtn">Create game (host)</button>
      <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
        <input id="roomIdInput" type="text" placeholder="Room ID" style="flex:1; padding:12px 14px; border-radius:10px; border:1px solid rgba(255,255,255,0.2); background:rgba(0,0,0,0.3); color:inherit; font-size:0.95rem;" maxlength="20" />
        <button id="joinGameBtn" class="playBtn" style="background:rgba(255,255,255,0.2); color:inherit;">Join game</button>
      </div>
      <button id="playOfflineBtn" class="playBtn" style="margin-top:10px; background:rgba(255,255,255,0.15); color:inherit;">Play Offline</button>
      <details class="controls-dropdown">
        <summary>Controls</summary>
        <div class="controls-inner controls">
          <kbd>WASD</kbd><span class="sep">•</span>  jump <kbd>Space</kbd><span class="sep">•</span> sprint<br/>
          <kbd>E</kbd><span class="sep">•</span> grab <kbd>Wheel</kbd><span class="sep">•</span> pull/push <kbd>LMB</kbd><span class="sep">•</span> throw <kbd>RMB</kbd><span class="sep">•</span> drop <kbd>R</kbd><span class="sep">•</span> reset<br/>
          <kbd>P</kbd><span class="sep">•</span> 3rd person <kbd>Look down</kbd><span class="sep">+</span><kbd>LMB</kbd><span class="sep">•</span> telekinetic jump (hold to charge)
        </div>
      </details>
      <div id="menuStatus" class="status">Click Play to join the battle</div>
    </div>
  </div>

  <div id="hud">
    <b>Room: <span id="hudRoom">—</span></b>
    <div id="stats">Objects: 0 • Held: none • FPS: —</div>
  </div>
  <div id="crosshair"></div>
  <div id="chargeBar"><div id="chargeFill"></div></div>
  <div id="hint">Click to lock mouse • E to grab • Wheel to adjust distance • Hold LMB to charge throw</div>

  <div id="pauseOverlay">
    <div id="pauseSidebar">
      <h2>Paused</h2>
      <button type="button" class="pauseBtn pauseBtnPrimary" id="resumeBtn">Resume</button>
      <button type="button" class="pauseBtn" id="returnToMenuBtn">Return to Menu</button>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

    // ---------------------------
    // PeerJS multiplayer (P2P via https://peerjs.com/)
    // ---------------------------
    const WORLD_SEED = 12345;
    function seededRandom(seed) {
      return function () {
        seed = (seed * 16807) % 2147483647;
        return seed / 2147483647;
      };
    }
    function generateObjectLayout() {
      const r = seededRandom(WORLD_SEED);
      const objects = [];
      for (let i = 0; i < 160; i++) {
        const x = -165 + r() * 330;
        const z = -165 + r() * 330;
        const y = 0.7 + r() * 0.4;
        const pick = r();
        let sx, sy, sz, mass;
        if (pick < 0.55) {
          sx = 0.6 + r() * 0.8; sy = 0.6 + r() * 1.0; sz = 0.6 + r() * 0.8;
          mass = 0.8 + r() * 1.7;
        } else if (pick < 0.85) {
          const rad = 0.25 + r() * 0.3;
          const h = 0.8 + r() * 1.0;
          sx = rad * 2; sy = h; sz = rad * 2;
          mass = 0.6 + r() * 1.0;
        } else {
          sx = 1.5 + r() * 1.3; sy = 0.7 + r() * 0.5; sz = 2.4 + r() * 2.4;
          mass = 2.5 + r() * 3.5;
        }
        objects.push({
          id: i,
          x, y, z,
          vx: 0, vy: 0, vz: 0,
          mass,
          size: { x: sx, y: sy, z: sz },
          heldBy: null,
        });
      }
      return objects;
    }
    const DUCK_COLORS = [0xf5d547, 0x7dd3fc, 0xa3e635, 0xfb7185, 0xc084fc];
    function getNextColor(players) {
      const used = new Set([...players.values()].map((p) => p.color));
      for (const c of DUCK_COLORS) {
        if (!used.has(c)) return c;
      }
      return DUCK_COLORS[players.size % DUCK_COLORS.length];
    }

    const net = {
      peer: null,
      isHost: false,
      myId: null,
      connections: new Map(),
      hostState: null,
      messageHandlers: new Map(),
      onConnect: null,
      onConnectError: null,
      send(msg) {
        if (net.isHost) {
          net.connections.forEach((conn) => conn.send(msg));
        } else {
          const c = net.connections.get(net.hostId);
          if (c && c.open) c.send(msg);
        }
      },
      sendTo(peerId, msg) {
        const c = net.connections.get(peerId);
        if (c && c.open) c.send(msg);
      },
      broadcast(excludeId, msg) {
        net.connections.forEach((conn, peerId) => {
          if (peerId !== excludeId && conn.open) conn.send(msg);
        });
      },
      on(type, handler) {
        if (!net.messageHandlers.has(type)) net.messageHandlers.set(type, []);
        net.messageHandlers.get(type).push(handler);
      },
      emit(type, data) {
        const handlers = net.messageHandlers.get(type);
        if (handlers) handlers.forEach((h) => h(data));
      },
      handleMessage(fromId, msg) {
        if (!msg || !msg.type) return;
        if (net.isHost) net.handleHostMessage(fromId, msg);
        else net.emit(msg.type, msg);
      },
      handleHostMessage(fromId, msg) {
        const { type } = msg;
        const players = net.hostState.players;
        const objects = net.hostState.objects;
        const id = fromId;
        let p = players.get(id);

        if (type === "playerUpdate") {
          if (!p) return;
          p.x = msg.x;
          p.y = msg.y;
          p.z = msg.z;
          p.yaw = msg.yaw;
          p.pitch = msg.pitch;
          p.velY = msg.velY ?? p.velY;
          p.holdDistance = msg.holdDistance;
          p.holdHeight = msg.holdHeight;
          net.broadcast(null, { type: "playerUpdate", id, ...msg });
          net.emit("playerUpdate", { id, ...msg }); // host view sync
          if (msg.heldPlayerId) {
            const held = players.get(msg.heldPlayerId);
            if (held && held.grabbedBy === id) {
              const dist = msg.holdDistance ?? 6;
              const height = msg.holdHeight ?? 5;
              const x = p.x + -Math.sin(p.yaw) * dist;
              const z = p.z + -Math.cos(p.yaw) * dist;
              net.sendTo(msg.heldPlayerId, { type: "grabbedPosition", x, y: height, z });
            }
          }
          return;
        }
        if (type === "grab") {
          const obj = objects[msg.objectId];
          if (!obj || !p || obj.heldBy !== null) return;
          obj.heldBy = id;
          p.heldId = msg.objectId;
          net.connections.forEach((conn) => conn.send({ type: "grab", playerId: id, objectId: msg.objectId }));
          net.emit("grab", { playerId: id, objectId: msg.objectId });
          return;
        }
        if (type === "throw") {
          const { objectId, vx, vy, vz } = msg;
          const obj = objects[objectId];
          if (!obj || !p || obj.heldBy !== id) return;
          obj.heldBy = null;
          p.heldId = null;
          obj.vx = vx;
          obj.vy = vy;
          obj.vz = vz;
          net.broadcast(null, { type: "throw", playerId: id, objectId, vx, vy, vz });
          net.emit("throw", { playerId: id, objectId, vx, vy, vz });
          return;
        }
        if (type === "drop") {
          const obj = objects[msg.objectId];
          if (!obj || !p || obj.heldBy !== id) return;
          obj.heldBy = null;
          p.heldId = null;
          net.broadcast(null, { type: "drop", playerId: id, objectId: msg.objectId });
          net.emit("drop", { playerId: id, objectId: msg.objectId });
          return;
        }
        if (type === "grabPlayer") {
          const grabbed = players.get(msg.grabbedId);
          if (!p || !grabbed || grabbed.grabbedBy) return;
          grabbed.grabbedBy = id;
          net.broadcast(null, { type: "playerGrabbed", grabberId: id, grabbedId: msg.grabbedId });
          net.emit("playerGrabbed", { grabberId: id, grabbedId: msg.grabbedId });
          return;
        }
        if (type === "releasePlayer") {
          const grabbedId = [...players.entries()].find(([_, pl]) => pl.grabbedBy === id)?.[0];
          if (!grabbedId) return;
          players.get(grabbedId).grabbedBy = null;
          net.broadcast(null, { type: "playerReleased", grabberId: id, grabbedId });
          net.emit("playerReleased", { grabberId: id, grabbedId });
          return;
        }
        if (type === "throwPlayer") {
          const { grabbedId, vx, vy, vz } = msg;
          const grabbed = players.get(grabbedId);
          if (!grabbed || grabbed.grabbedBy !== id) return;
          grabbed.grabbedBy = null;
          net.sendTo(grabbedId, { type: "playerThrown", vx, vy, vz });
          net.broadcast(null, { type: "playerReleased", grabberId: id, grabbedId });
          return;
        }
        if (type === "hitPlayer") {
          if (players.has(msg.targetId)) net.sendTo(msg.targetId, { type: "hitBy", vx: msg.vx, vy: msg.vy, vz: msg.vz });
          return;
        }
        if (type === "objectSync") {
          const obj = objects[msg.id];
          if (!obj || obj.heldBy !== null) return;
          obj.x = msg.x;
          obj.y = msg.y;
          obj.z = msg.z;
          obj.vx = msg.vx;
          obj.vy = msg.vy;
          obj.vz = msg.vz;
          net.broadcast(id, { type: "objectSync", id: msg.id, x: msg.x, y: msg.y, z: msg.z, vx: msg.vx, vy: msg.vy, vz: msg.vz });
          net.emit("objectSync", { id: msg.id, x: msg.x, y: msg.y, z: msg.z, vx: msg.vx, vy: msg.vy, vz: msg.vz });
          return;
        }
      },
    };

    // Duck model (loaded async)
    let duckModelTemplate = null;
    async function loadDuckModel() {
      try {
        const gltf = await new Promise((resolve, reject) => {
          new GLTFLoader().load("duck_.glb", resolve, undefined, reject);
        });
        const model = gltf.scene;
        model.traverse((o) => {
          if (o.isMesh) {
            o.castShadow = true;
            o.receiveShadow = true;
          }
        });
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const scale = 1.2 / Math.max(size.x, size.y, size.z);
        model.scale.setScalar(scale);
        model.rotation.y = 0;  // GLB faces -Z by default; no flip needed
        // Center model so pivot aligns with collision/grabbable bounds
        const box2 = new THREE.Box3().setFromObject(model);
        const center = box2.getCenter(new THREE.Vector3());
        model.position.sub(center);
        // Duck tail extends the bounding box; nudge pivot toward body so focus ring aligns
        model.position.z += 0.2;
        // Align model feet with ground (collision uses center at 1.1, feet at 0)
        const modelHalfHeight = (box2.max.y - box2.min.y) * 0.5;
        model.position.y -= (1.1 - modelHalfHeight);
        model.rotation.y = Math.PI;  // Face -Z (forward) to match movement
        duckModelTemplate = model;
      } catch (err) {
        console.warn("Could not load duck_.glb (run via server: npm start). Using fallback.", err);
        duckModelTemplate = makeFallbackDuckModel();
      }
    }

    function makeFallbackDuckModel() {
      const g = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.SphereGeometry(0.55, 12, 10),
        new THREE.MeshStandardMaterial({ color: 0xf5d547, roughness: 0.65 })
      );
      body.position.set(0, 0.55, 0);
      body.rotation.y = Math.PI;
      g.add(body);
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 12, 10),
        new THREE.MeshStandardMaterial({ color: 0xf7dd61, roughness: 0.65 })
      );
      head.position.set(0, 1.1, 0.35);
      head.rotation.y = Math.PI;
      g.add(head);
      const beak = new THREE.Mesh(
        new THREE.BoxGeometry(0.28, 0.14, 0.28),
        new THREE.MeshStandardMaterial({ color: 0xf59e0b, roughness: 0.7 })
      );
      beak.position.set(0, 1.02, 0.72);
      beak.rotation.y = Math.PI;
      g.add(beak);
      g.traverse((o) => { if (o.isMesh) o.castShadow = o.receiveShadow = true; });
      return g;
    }

    function cloneDuckModel(color = null) {
      if (!duckModelTemplate) return null;
      const clone = duckModelTemplate.clone();
      clone.traverse((o) => {
        if (o.isMesh && o.material) {
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          o.material = mats.length === 1 ? mats[0].clone() : mats.map((m) => m.clone());
          if (color) {
            const toColor = (m) => { if (m.color) m.color.setHex(color); };
            Array.isArray(o.material) ? o.material.forEach(toColor) : toColor(o.material);
          }
        }
      });
      return clone;
    }

    // ---------------------------
    // SFX
    // ---------------------------
    const sfx = {};
    ["grab", "throw", "shatter", "scream", "scream2"].forEach((name) => {
      const a = new Audio(`sfx/${name}.mp3`);
      a.volume = 0.7;
      sfx[name] = a;
    });

    function playSfx(name) {
      const a = sfx[name];
      if (!a) return;
      a.currentTime = 0;
      a.play().catch(() => {});
    }

    // ---------------------------
    // Basic setup
    // ---------------------------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1020, 80, 260);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 10);

    // Lighting
    const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x1b2338, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.05);
    sun.position.set(35, 60, 25);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.near = 1;
    sun.shadow.camera.far = 200;
    sun.shadow.camera.left = -80;
    sun.shadow.camera.right = 80;
    sun.shadow.camera.top = 80;
    sun.shadow.camera.bottom = -80;
    scene.add(sun);

    // ---------------------------
    // Pointer lock + look
    // ---------------------------
    let pointerLocked = false;
    let yaw = 0;
    let pitch = 0;

    const menu = document.getElementById("menu");
    const playBtn = document.getElementById("playBtn");
    const menuStatus = document.getElementById("menuStatus");

    function startAsHost(roomId) {
      net.isHost = true;
      net.myId = roomId;
      myId = roomId;
      net.hostState = {
        players: new Map([[roomId, { x: 0, y: 2, z: 18, yaw: 0, pitch: 0, velY: 0, heldId: null, grabbedBy: null, color: DUCK_COLORS[0] }]]),
        objects: generateObjectLayout(),
      };
      net.peer = new Peer(roomId, { secure: true, host: "0.peerjs.com", port: 443, path: "/" });
      net.peer.on("open", () => {
        menuStatus.textContent = "Room: " + roomId + " — Share this ID or link. Waiting for players...";
        socket = {
          emit(type, payload) {
            const msg = typeof payload === "object" && payload !== null && !Array.isArray(payload) && !payload.type ? { type, ...payload } : { type, ...(payload !== undefined ? (type === "grab" || type === "drop" ? { objectId: payload } : payload) : {}) };
            net.send(msg);
          },
        };
        setupNetHandlers();
        net.onConnect && net.onConnect();
      });
      net.peer.on("connection", (conn) => {
        conn.on("open", () => {
          const id = conn.peer;
          net.connections.set(id, conn);
          const color = getNextColor(net.hostState.players);
          net.hostState.players.set(id, { x: 0, y: 2, z: 18, yaw: 0, pitch: 0, velY: 0, heldId: null, grabbedBy: null, color });
          conn.send({
            type: "init",
            yourId: id,
            players: Object.fromEntries([...net.hostState.players.entries()].map(([k, v]) => [k, { ...v, id: k }])),
            objects: net.hostState.objects.map((o) => ({ id: o.id, x: o.x, y: o.y, z: o.z, vx: o.vx, vy: o.vy, vz: o.vz, mass: o.mass, size: o.size, heldBy: o.heldBy })),
          });
          net.broadcast(id, { type: "playerJoined", id, x: 0, y: 2, z: 18, yaw: 0, pitch: 0, velY: 0, heldId: null, color });
          // Host view: show new player
          otherPlayers.set(id, { x: 0, y: 2, z: 18, yaw: 0, pitch: 0, velY: 0, heldId: null, grabbedBy: null, color });
          const mesh = createOtherPlayerDuck(id, color);
          mesh.position.set(0, 2, 18);
          otherPlayerMeshes.set(id, mesh);
          conn.on("data", (msg) => net.handleMessage(id, msg));
          conn.on("close", () => {
            const p = net.hostState.players.get(id);
            if (p?.heldId != null) {
              net.hostState.objects[p.heldId].heldBy = null;
              net.broadcast(null, { type: "drop", playerId: id, objectId: p.heldId });
            }
            const grabbedId = [...net.hostState.players.entries()].find(([_, pl]) => pl.grabbedBy === id)?.[0];
            if (grabbedId) {
              net.hostState.players.get(grabbedId).grabbedBy = null;
              net.broadcast(null, { type: "playerReleased", grabberId: id, grabbedId });
            }
            net.hostState.players.delete(id);
            net.connections.delete(id);
            net.broadcast(null, { type: "playerLeft", id });
            net.emit("playerLeft", id); // host view: remove other player mesh
          });
        });
      });
      net.peer.on("error", (err) => {
        menuStatus.textContent = "Error: " + (err.message || err.type || "Could not create room");
      });
    }

    function startAsClient(hostId) {
      net.isHost = false;
      net.hostId = hostId;
      net.messageHandlers.clear(); // fresh handlers so we don't double-register
      setupNetHandlers();          // register before connecting so we don't miss init
      net.peer = new Peer({ secure: true, host: "0.peerjs.com", port: 443, path: "/" });
      net.peer.on("open", () => {
        const conn = net.peer.connect(hostId);
        net.connections.set(hostId, conn);
        conn.on("data", (msg) => net.handleMessage(hostId, msg)); // receive immediately so init isn't lost
        conn.on("open", () => {
          net.myId = net.peer.id;
          myId = net.peer.id;
          socket = {
            emit(type, payload) {
              const msg = typeof payload === "object" && payload !== null && !Array.isArray(payload) && !payload.type ? { type, ...payload } : { type, ...(payload !== undefined ? (type === "grab" || type === "drop" ? { objectId: payload } : payload) : {}) };
              net.send(msg);
            },
          };
          conn.on("close", () => {
            menuStatus.textContent = "Host disconnected";
            net.connections.delete(hostId);
          });
          net.onConnect && net.onConnect();
        });
        conn.on("error", () => { menuStatus.textContent = "Connection failed. Check Room ID."; });
      });
      net.peer.on("error", (err) => {
        menuStatus.textContent = "Error: " + (err.message || err.type || "Could not connect");
      });
    }

    function randomRoomId() {
      return "duck-" + Math.random().toString(36).slice(2, 10);
    }

    let hadPointerLock = false; // true after user has entered game at least once
    const pauseOverlay = document.getElementById("pauseOverlay");
    const returnToMenuBtn = document.getElementById("returnToMenuBtn");

    document.addEventListener("pointerlockchange", () => {
      pointerLocked = (document.pointerLockElement === renderer.domElement);
      if (pointerLocked) {
        hadPointerLock = true;
        menu.classList.add("hidden");
        if (pauseOverlay) pauseOverlay.classList.remove("visible");
      } else {
        // Left pointer lock: if we were in game, show pause sidebar; else show main menu
        if (hadPointerLock && pauseOverlay) {
          pauseOverlay.classList.add("visible");
          menu.classList.add("hidden");
        } else {
          if (pauseOverlay) pauseOverlay.classList.remove("visible");
          menu.classList.remove("hidden");
        }
      }
    });

    function resumeGame() {
      if (pauseOverlay) pauseOverlay.classList.remove("visible");
      renderer.domElement.requestPointerLock();
    }

    const resumeBtn = document.getElementById("resumeBtn");
    if (resumeBtn) resumeBtn.addEventListener("click", resumeGame);

    if (returnToMenuBtn) {
      returnToMenuBtn.addEventListener("click", () => {
        hadPointerLock = false;
        if (pauseOverlay) pauseOverlay.classList.remove("visible");
        menu.classList.remove("hidden");
        document.exitPointerLock?.();
      });
    }

    if (pauseOverlay) {
      pauseOverlay.addEventListener("click", (e) => {
        if (e.target === pauseOverlay) resumeGame();
      });
    }

    let duck = null;
    let camPivot = null;

    document.addEventListener("mousemove", (e) => {
      if (!pointerLocked) return;
      const sensitivity = 0.004;
      yaw   -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      pitch = Math.max(-1.45, Math.min(1.45, pitch));
      if (duck && camPivot) {
        duck.rotation.y = yaw;
        camPivot.rotation.x = pitch;
      }
    });

    // ---------------------------
    // "Physics-lite" rigid bodies
    // ---------------------------
    const GRAVITY = 28;  // units/s^2
    const DAMPING = 0.985;
    const FLOOR_Y = 0;

    const dynamic = []; // objects with velocity
    const colliders = []; // static AABBs: {min,max}
    const buildings = []; // { mesh, box } — parallel to colliders for buildings
    const interactables = []; // dynamic targets for telekinesis

    function makeAABBFromMesh(mesh) {
      const box = new THREE.Box3().setFromObject(mesh);
      return box;
    }

    function addStaticCollider(mesh, isBuilding = false) {
      const box = makeAABBFromMesh(mesh);
      colliders.push(box);
      if (isBuilding) buildings.push({ mesh, box, destroyed: false });
    }

    // Simple AABB check for player vs walls/buildings
    function aabbIntersects(a, b) {
      return (a.min.x <= b.max.x && a.max.x >= b.min.x) &&
             (a.min.y <= b.max.y && a.max.y >= b.min.y) &&
             (a.min.z <= b.max.z && a.max.z >= b.min.z);
    }

    // ---------------------------
    // City map generation
    // ---------------------------
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(500, 500),
      new THREE.MeshStandardMaterial({ color: 0x0f172a, roughness: 0.95, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Roads (grid)
    const roadMat = new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 0.95 });
    const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 0.9 });

    function addRoad(x, z, w, d) {
      const m = new THREE.Mesh(new THREE.BoxGeometry(w, 0.2, d), roadMat);
      m.position.set(x, 0.1, z);
      m.receiveShadow = true;
      scene.add(m);
    }
    function addSidewalk(x, z, w, d) {
      const m = new THREE.Mesh(new THREE.BoxGeometry(w, 0.35, d), sidewalkMat);
      m.position.set(x, 0.175, z);
      m.receiveShadow = true;
      scene.add(m);
    }

    // City blocks
    const BLOCKS = 7;
    const SPACING = 28;
    const ROAD = 10;

    // roads between blocks
    for (let i = -BLOCKS; i <= BLOCKS; i++) {
      addRoad(i * SPACING, 0, ROAD, 2 * BLOCKS * SPACING + 200);
      addRoad(0, i * SPACING, 2 * BLOCKS * SPACING + 200, ROAD);
      addSidewalk(i * SPACING + 7, 0, 2.5, 2 * BLOCKS * SPACING + 200);
      addSidewalk(i * SPACING - 7, 0, 2.5, 2 * BLOCKS * SPACING + 200);
      addSidewalk(0, i * SPACING + 7, 2 * BLOCKS * SPACING + 200, 2.5);
      addSidewalk(0, i * SPACING - 7, 2 * BLOCKS * SPACING + 200, 2.5);
    }

    // Buildings
    const bMats = [
      new THREE.MeshStandardMaterial({ color: 0x334155, roughness: 0.9 }),
      new THREE.MeshStandardMaterial({ color: 0x475569, roughness: 0.9 }),
      new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.9 }),
      new THREE.MeshStandardMaterial({ color: 0x3f3f46, roughness: 0.9 }),
    ];

    function rand(min, max) { return min + Math.random() * (max - min); }
    const worldRand = seededRandom(12345); // seededRandom defined earlier (PeerJS section)
    function worldRandRange(min, max) { return min + worldRand() * (max - min); }

    function addBuilding(cx, cz, w, d, h) {
      const geo = new THREE.BoxGeometry(w, h, d);
      const mat = bMats[(Math.random() * bMats.length) | 0];
      const m = new THREE.Mesh(geo, mat);
      m.position.set(cx, h / 2, cz);
      m.castShadow = true;
      m.receiveShadow = true;
      scene.add(m);
      addStaticCollider(m, true);
      return m;
    }

    // Create blocks of buildings (deterministic for multiplayer)
    for (let bx = -BLOCKS; bx <= BLOCKS; bx++) {
      for (let bz = -BLOCKS; bz <= BLOCKS; bz++) {
        const px = bx * SPACING;
        const pz = bz * SPACING;
        if (Math.abs(px) < ROAD || Math.abs(pz) < ROAD) continue;
        const count = 3 + ((worldRand() * 4) | 0);
        for (let i = 0; i < count; i++) {
          const w = worldRandRange(6, 14);
          const d = worldRandRange(6, 14);
          const h = worldRandRange(10, 42);
          const ox = worldRandRange(-8, 8);
          const oz = worldRandRange(-8, 8);
          addBuilding(px + ox, pz + oz, w, d, h);
        }
      }
    }
    for (let i = 0; i < 22; i++) {
      const x = worldRandRange(-140, 140);
      const z = worldRandRange(-140, 140);
      if (Math.abs(x) < 18 || Math.abs(z) < 18) continue;
      addBuilding(x, z, worldRandRange(10, 22), worldRandRange(10, 22), worldRandRange(45, 95));
    }

    // ---------------------------
    // Duck player
    // ---------------------------
    const menuStatusEl = document.getElementById("menuStatus");
    const roomIdInput = document.getElementById("roomIdInput");
    if (menuStatusEl) menuStatusEl.textContent = "Loading duck model...";
    await loadDuckModel();
    if (menuStatusEl) menuStatusEl.textContent = "Create game or enter Room ID to join";
    duck = new THREE.Object3D();
    duck.position.set(0, 2, 18);
    scene.add(duck);

    const duckModel = cloneDuckModel();
    if (duckModel) {
      duckModel.position.set(0, 0, 0);
      duckModel.visible = false;  // 1st person by default
      duck.add(duckModel);
    }

    // Camera offset: a bit above duck for 1st-person-ish
    camPivot = new THREE.Object3D();
    camPivot.position.set(0, 1.35, 0);
    duck.add(camPivot);
    camPivot.add(camera);
    camera.position.set(0, 0.05, 0.2);

    let thirdPersonMode = false;
    const CAM_1ST_PERSON = new THREE.Vector3(0, 0.05, 0.2);
    const CAM_3RD_PERSON = new THREE.Vector3(0, 0.5, 5.5);

    function setThirdPerson(on) {
      if (!duck || !camPivot || !camera) return;
      thirdPersonMode = on;
      camera.position.set(0, on ? 0.5 : 0.05, on ? 5.5 : 0.2);
      if (duckModel) duckModel.visible = on;
    }

    // ---------------------------
    // Multiplayer
    // ---------------------------
    let socket = null; // compatibility adapter: set when Peer connected; socket.emit(type, data) -> net.send(...)
    let myId = null;
    const otherPlayers = new Map(); // id -> { x, y, z, yaw, pitch, heldId, holdDistance, holdHeight }
    const otherPlayerMeshes = new Map(); // id -> THREE.Group (duck mesh)
    const objectHeldBy = new Map(); // objectId -> playerId (for objects held by others)
    let heldPlayerId = null;       // when we're holding another player
    let grabbedBy = null;          // id of player holding us
    let lastGrabbedPosition = null;

    // Invisible box used for grab detection so it matches the collision hitbox (DUCK_SIZE)
    function makeGrabBox(userData) {
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(DUCK_SIZE.x, DUCK_SIZE.y, DUCK_SIZE.z),
        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false })
      );
      box.userData = userData;
      return box;
    }

    function createOtherPlayerDuck(id, color = 0x7dd3fc) {
      const group = new THREE.Group();
      const model = cloneDuckModel(color);
      if (model) group.add(model);
      group.userData.otherPlayerId = id;
      const grabBox = makeGrabBox({ otherPlayerId: id });
      group.add(grabBox);
      group.userData.grabBox = grabBox;
      scene.add(group);
      interactables.push(grabBox);
      return group;
    }

    net.onConnect = () => {
      const hud = document.getElementById("hud");
      const roomEl = document.getElementById("hudRoom");
      const roomCode = net.isHost ? net.myId : net.hostId;
      if (hud) hud.classList.add("online");
      if (roomEl && roomCode) roomEl.textContent = roomCode;
      menuStatus.textContent = "Connected! Locking pointer...";
      renderer.domElement.requestPointerLock();
    };

    function setupNetHandlers() {
      net.on("init", (data) => {
        myId = data.yourId;
        objectHeldBy.clear();
        for (const [id, p] of Object.entries(data.players)) {
          if (id === myId) continue;
          otherPlayers.set(id, p);
          const mesh = createOtherPlayerDuck(id, p.color);
          mesh.position.set(p.x, p.y, p.z);
          mesh.rotation.y = p.yaw;
          otherPlayerMeshes.set(id, mesh);
        }
        for (const o of data.objects) {
          if (o.heldBy) objectHeldBy.set(o.id, o.heldBy);
          const m = dynamic[o.id];
          if (m) {
            m.position.set(o.x, o.y, o.z);
            m.userData.vel.set(o.vx, o.vy, o.vz);
          }
        }
      });
      net.on("playerJoined", (p) => {
        otherPlayers.set(p.id, p);
        const mesh = createOtherPlayerDuck(p.id, p.color);
        mesh.position.set(p.x, p.y, p.z);
        otherPlayerMeshes.set(p.id, mesh);
      });
      net.on("playerLeft", (id) => {
        if (heldPlayerId === id) heldPlayerId = null;
        otherPlayers.delete(id);
        const mesh = otherPlayerMeshes.get(id);
        if (mesh) {
          const grabBox = mesh.userData.grabBox;
          if (grabBox) {
            const i = interactables.indexOf(grabBox);
            if (i >= 0) interactables.splice(i, 1);
          }
          scene.remove(mesh);
          otherPlayerMeshes.delete(id);
        }
        for (const [objId, pid] of objectHeldBy) {
          if (pid === id) objectHeldBy.delete(objId);
        }
      });
      net.on("playerUpdate", (data) => {
        const { id, x, y, z, yaw, pitch, heldId, holdDistance, holdHeight } = data;
        if (id === myId) return;
        const p = otherPlayers.get(id) || {};
        Object.assign(p, { x, y, z, yaw, pitch, heldId, holdDistance, holdHeight });
        otherPlayers.set(id, p);
        const mesh = otherPlayerMeshes.get(id);
        if (mesh) {
          mesh.position.set(x, y, z);
          mesh.rotation.y = yaw;
        }
      });
      net.on("grab", (data) => {
        const { playerId, objectId } = data;
        if (playerId !== myId) objectHeldBy.set(objectId, playerId);
      });
      net.on("throw", (data) => {
        const { playerId, objectId, vx, vy, vz } = data;
        objectHeldBy.delete(objectId);
        const m = dynamic[objectId];
        if (m && playerId !== myId) m.userData.vel.add(new THREE.Vector3(vx, vy, vz));
      });
      net.on("drop", (data) => {
        objectHeldBy.delete(data.objectId);
      });
      net.on("objectSync", (data) => {
        const m = dynamic[data.id];
        if (m && !objectHeldBy.has(data.id)) {
          m.position.set(data.x, data.y, data.z);
          m.userData.vel.set(data.vx || 0, data.vy || 0, data.vz || 0);
        }
      });
      net.on("playerGrabbed", (data) => {
        if (data.grabbedId === myId) grabbedBy = data.grabberId;
      });
      net.on("playerReleased", (data) => {
        if (data.grabbedId === myId) grabbedBy = null;
        if (data.grabberId === myId && data.grabbedId === heldPlayerId) heldPlayerId = null;
      });
      net.on("grabbedPosition", (data) => {
        lastGrabbedPosition = data;
      });
      net.on("playerThrown", (data) => {
        grabbedBy = null;
        const { vx, vy, vz } = data;
        launchVel.set(vx, 0, vz);
        velY = vy;
        grounded = false;
      });
      net.on("hitBy", (data) => {
        const { vx, vy, vz } = data;
        launchVel.addScaledVector(new THREE.Vector3(vx, 0, vz), 1);
        velY += vy;
        grounded = false;
      });
    }

    // Menu buttons (attached after load so setupNetHandlers, otherPlayers, etc. exist)
    document.getElementById("createGameBtn").addEventListener("click", () => {
      menuStatus.textContent = "Creating room...";
      if (typeof Peer === "undefined") {
        menuStatus.textContent = "PeerJS failed to load. Check connection.";
        return;
      }
      const roomId = randomRoomId();
      startAsHost(roomId);
      if (roomIdInput) roomIdInput.value = roomId;
    });
    document.getElementById("joinGameBtn").addEventListener("click", () => {
      const hostId = (roomIdInput && roomIdInput.value.trim()) || prompt("Enter Room ID:");
      if (!hostId || !hostId.trim()) return;
      menuStatus.textContent = "Joining...";
      if (typeof Peer === "undefined") {
        menuStatus.textContent = "PeerJS failed to load.";
        return;
      }
      startAsClient(hostId.trim());
    });
    document.getElementById("playOfflineBtn").addEventListener("click", () => {
      menuStatus.textContent = "Playing offline...";
      renderer.domElement.requestPointerLock();
    });

    // Player movement
    const keys = new Set();
    document.addEventListener("keydown", (e) => {
      keys.add(e.code);
      if (e.code === "Escape") document.exitPointerLock?.(); // leaves game → pointerlockchange shows pause sidebar
      if (e.code === "KeyP") setThirdPerson(!thirdPersonMode);
    });
    document.addEventListener("keyup", (e) => keys.delete(e.code));

    let velY = 0;
    let grounded = false;
    const launchVel = new THREE.Vector3(); // telekinetic jump horizontal boost

    // Shared duck hitbox: same for player, other players, and NPCs (model and collision match)
    const DUCK_HALF = new THREE.Vector3(0.6, 1.2, 0.6);
    const DUCK_SIZE = new THREE.Vector3(1.2, 2.4, 1.2); // full AABB size

    function playerAABB(nextPos) {
      return new THREE.Box3(nextPos.clone().sub(DUCK_HALF), nextPos.clone().add(DUCK_HALF));
    }

    function otherPlayerAABB(pos) {
      return new THREE.Box3(pos.clone().sub(DUCK_HALF), pos.clone().add(DUCK_HALF));
    }

    function resolvePlayerCollisions(nextPos) {
      let pos = nextPos.clone();
      const pBox = playerAABB(pos);
      const feetY = pos.y - DUCK_HALF.y;

      // First: check for landing ON TOP of buildings
      let roofTop = -Infinity;
      for (const c of colliders) {
        if (!aabbIntersects(pBox, c)) continue;
        const overlapX = Math.min(pBox.max.x - c.min.x, c.max.x - pBox.min.x);
        const overlapZ = Math.min(pBox.max.z - c.min.z, c.max.z - pBox.min.z);
        const nearRoof = feetY >= c.max.y - 0.8 && feetY <= c.max.y + 0.5;
        const onTop = nearRoof && overlapX > 0.2 && overlapZ > 0.2;
        if (onTop && c.max.y > roofTop) roofTop = c.max.y;
      }
      if (roofTop > -Infinity && (velY <= 0 || grounded)) {
        pos.y = roofTop + DUCK_HALF.y;
        velY = 0;
        grounded = true;
        return pos;
      }

      // Otherwise: hitting sides — push back on XZ
      for (const c of colliders) {
        if (!aabbIntersects(playerAABB(pos), c)) continue;
        const pBox2 = playerAABB(pos);
        const overlapX = Math.min(pBox2.max.x - c.min.x, c.max.x - pBox2.min.x);
        const overlapZ = Math.min(pBox2.max.z - c.min.z, c.max.z - pBox2.min.z);

        if (overlapX < overlapZ) {
          if (pos.x > (c.min.x + c.max.x) * 0.5) pos.x += overlapX + 0.01;
          else pos.x -= overlapX + 0.01;
        } else {
          if (pos.z > (c.min.z + c.max.z) * 0.5) pos.z += overlapZ + 0.01;
          else pos.z -= overlapZ + 0.01;
        }
      }
      return pos;
    }

    // ---------------------------
    // Interactables (mayhem props)
    // ---------------------------
    const propMat1 = new THREE.MeshStandardMaterial({ color: 0x94a3b8, roughness: 0.8 });
    const propMat2 = new THREE.MeshStandardMaterial({ color: 0xfb7185, roughness: 0.7 });
    const propMat3 = new THREE.MeshStandardMaterial({ color: 0x60a5fa, roughness: 0.7 });
    const propMat4 = new THREE.MeshStandardMaterial({ color: 0xa3e635, roughness: 0.7 });

    function addDynamicBox(x, y, z, sx, sy, sz, mass = 1, mat = propMat1) {
      const m = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), mat);
      m.position.set(x, y, z);
      m.castShadow = true;
      m.receiveShadow = true;
      scene.add(m);
      m.userData.vel = new THREE.Vector3();
      m.userData.mass = mass;
      m.userData.size = new THREE.Vector3(sx, sy, sz);
      dynamic.push(m);
      interactables.push(m);
      return m;
    }

    function addDynamicCylinder(x, y, z, r, h, mass = 0.8, mat = propMat2) {
      const m = new THREE.Mesh(new THREE.CylinderGeometry(r, r, h, 18), mat);
      m.position.set(x, y, z);
      m.castShadow = true;
      m.receiveShadow = true;
      scene.add(m);
      m.userData.vel = new THREE.Vector3();
      m.userData.mass = mass;
      m.userData.size = new THREE.Vector3(r * 2, h, r * 2);
      dynamic.push(m);
      interactables.push(m);
      return m;
    }

    // scatter props (deterministic - must match server)
    for (let i = 0; i < 160; i++) {
      const x = worldRandRange(-165, 165);
      const z = worldRandRange(-165, 165);
      const y = 0.7 + worldRandRange(0, 0.4);
      const pick = worldRand();
      if (pick < 0.55) addDynamicBox(x, y, z, worldRandRange(0.6, 1.4), worldRandRange(0.6, 1.6), worldRandRange(0.6, 1.4), worldRandRange(0.8, 2.5), [propMat1,propMat3][(worldRand()*2)|0]);
      else if (pick < 0.85) addDynamicCylinder(x, y, z, worldRandRange(0.25, 0.55), worldRandRange(0.8, 1.8), worldRandRange(0.6, 1.6), propMat2);
      else addDynamicBox(x, y, z, worldRandRange(1.5, 2.8), worldRandRange(0.7, 1.2), worldRandRange(2.4, 4.8), worldRandRange(2.5, 6.0), propMat4);
    }

    // ---------------------------
    // Telekinesis system
    // ---------------------------
    const raycaster = new THREE.Raycaster();
    const aimDir = new THREE.Vector3();

    let held = null;
    let holdDistance = 6.5;
    let holdHeight = 2;    // how high the object floats above its grab point
    let holding = false;

    // A visible "focus" glow sphere for held objects
    const focus = new THREE.Mesh(
      new THREE.SphereGeometry(0.12, 16, 12),
      new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.0, emissive: 0x7dd3fc, emissiveIntensity: 1.2 })
    );
    focus.visible = false;
    scene.add(focus);

    // ---------------------------
    // Sparkle FX for held objects
    // ---------------------------
    const sparkleGroup = new THREE.Group();
    sparkleGroup.visible = false;
    scene.add(sparkleGroup);

    // Ring
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(0.55, 0.06, 10, 24),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0x7dd3fc,
        emissiveIntensity: 2.0,
        roughness: 0.3,
        metalness: 0.0,
        transparent: true,
        opacity: 0.95
      })
    );
    ring.castShadow = false;
    ring.receiveShadow = false;
    sparkleGroup.add(ring);

    // Particles (points)
    const SPARKS = 60;
    const sparksGeo = new THREE.BufferGeometry();
    const sparksPos = new Float32Array(SPARKS * 3);
    for (let i = 0; i < SPARKS; i++) {
      sparksPos[i * 3 + 0] = (Math.random() - 0.5) * 1.2;
      sparksPos[i * 3 + 1] = (Math.random() - 0.5) * 1.2;
      sparksPos[i * 3 + 2] = (Math.random() - 0.5) * 1.2;
    }
    sparksGeo.setAttribute("position", new THREE.BufferAttribute(sparksPos, 3));

    const sparksMat = new THREE.PointsMaterial({
      size: 0.06,
      transparent: true,
      opacity: 0.9
    });
    const sparks = new THREE.Points(sparksGeo, sparksMat);
    sparkleGroup.add(sparks);

    let sparkleT = 0;
    let scrollFeedback = 0;  // pops when you scroll to adjust distance
    function updateSparkles(dt) {
      if (!held && !heldPlayerId) { sparkleGroup.visible = false; scrollFeedback = 0; return; }
      sparkleGroup.visible = true;

      scrollFeedback = Math.max(0, scrollFeedback - dt * 5);

      sparkleGroup.position.copy(held ? held.position : focus.position);

      // Scale ring to object size
      const s = held.userData?.size;
      const radius = s ? Math.max(s.x, s.z) * 0.55 : 0.55;
      const baseScale = Math.max(0.7, radius);
      // Pop scale when scrolling
      const scrollPop = 1 + scrollFeedback * 0.35;
      ring.scale.setScalar(baseScale * scrollPop);

      // Snappier rotation
      sparkleT += dt;
      ring.rotation.x += dt * 4.5;
      ring.rotation.y += dt * 5.5;

      // "Orbit" sparks - faster, tighter orbits
      const posAttr = sparks.geometry.getAttribute("position");
      for (let i = 0; i < SPARKS; i++) {
        const a = sparkleT * 5.0 + i * 0.2;
        const r = 0.5 + 0.2 * Math.sin(sparkleT * 4.0 + i);
        posAttr.array[i * 3 + 0] = Math.cos(a) * r;
        posAttr.array[i * 3 + 1] = 0.1 + 0.25 * Math.sin(a * 1.2 + i);
        posAttr.array[i * 3 + 2] = Math.sin(a) * r;
      }
      posAttr.needsUpdate = true;

      // Snappier pulse + scroll glow
      const pulse = 0.8 + 0.2 * Math.sin(sparkleT * 12.0);
      const scrollGlow = scrollFeedback * 1.5;
      ring.material.opacity = Math.min(1, 0.7 + 0.3 * pulse + scrollGlow);
      ring.material.emissiveIntensity = 2.0 + scrollFeedback * 2.0;
      sparks.material.opacity = 0.7 + 0.3 * pulse + scrollFeedback * 0.4;
    }

    // ---------------------------
    // Telekinetic jump charge particles
    // ---------------------------
    const chargeJumpGroup = new THREE.Group();
    chargeJumpGroup.visible = false;
    scene.add(chargeJumpGroup);

    const CHARGE_PARTICLES = 48;
    const chargePartGeo = new THREE.BufferGeometry();
    const chargePartPos = new Float32Array(CHARGE_PARTICLES * 3);
    chargePartGeo.setAttribute("position", new THREE.BufferAttribute(chargePartPos, 3));

    const chargePartMat = new THREE.PointsMaterial({
      size: 0.12,
      color: 0x7dd3fc,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    const chargePartMesh = new THREE.Points(chargePartGeo, chargePartMat);
    chargeJumpGroup.add(chargePartMesh);

    let chargeJumpT = 0;
    function updateChargeJumpParticles(dt) {
      if (!chargingJump) {
        chargeJumpGroup.visible = false;
        return;
      }
      chargeJumpGroup.visible = true;
      chargeJumpGroup.position.copy(duck.position);
      chargeJumpGroup.position.y = duck.position.y - 0.5;

      chargeJumpT += dt;
      const frac = getChargeFraction();
      const radius = 0.8 + frac * 1.4;
      const height = 0.5 + frac * 1.2;
      const posAttr = chargePartGeo.getAttribute("position");

      for (let i = 0; i < CHARGE_PARTICLES; i++) {
        const a = chargeJumpT * 3.5 + (i / CHARGE_PARTICLES) * Math.PI * 2;
        const r = radius * (0.7 + 0.3 * Math.sin(chargeJumpT * 8 + i * 0.5));
        const h = (i / CHARGE_PARTICLES) * height * 2 - height;
        posAttr.array[i * 3 + 0] = Math.cos(a) * r;
        posAttr.array[i * 3 + 1] = h + 0.3 * Math.sin(chargeJumpT * 6 + i);
        posAttr.array[i * 3 + 2] = Math.sin(a) * r;
      }
      posAttr.needsUpdate = true;

      const pulse = 0.6 + 0.4 * Math.sin(chargeJumpT * 10);
      chargePartMat.opacity = (0.5 + frac * 0.5) * pulse;
      chargePartMat.size = 0.08 + frac * 0.08;
    }

    function forwardVector() {
      // Use the camera's actual world orientation (more reliable than manual yaw/pitch math)
      camera.getWorldDirection(aimDir);
      return aimDir.normalize();
    }

    function getAimHit() {
      const origin = camera.getWorldPosition(new THREE.Vector3());
      const dir = forwardVector().clone();
      raycaster.set(origin, dir);
      raycaster.far = 40;
      const hits = raycaster.intersectObjects(interactables, false);
      return hits.length ? hits[0] : null;
    }

    // Grab / throw / drop — hold left click to charge
    let charging = false;
    let chargeStart = 0;
    const CHARGE_MAX_TIME = 1.5; // seconds to reach full charge
    const CHARGE_MIN_STRENGTH = 28;
    const CHARGE_MAX_STRENGTH = 85;
    const TELEJUMP_MIN = 18;
    const TELEJUMP_MAX = 55;
    const TELEJUMP_PITCH_THRESHOLD = 0.4; // must look down this much to trigger
    const chargeBarEl = document.getElementById("chargeBar");
    const chargeFillEl = document.getElementById("chargeFill");

    function getChargeFraction() {
      if (!charging) return 0;
      return Math.min(1, (performance.now() - chargeStart) / 1000 / CHARGE_MAX_TIME);
    }

    function releaseHeldNPC() {
      if (held?.userData?.npc) held.userData.npc.grabbed = false;
    }

    let chargingJump = false;

    function releaseThrow() {
      if (heldPlayerId) {
        playSfx("throw");
        const frac = getChargeFraction();
        const strength = CHARGE_MIN_STRENGTH + frac * (CHARGE_MAX_STRENGTH - CHARGE_MIN_STRENGTH);
        const dir = forwardVector().clone();
        const impulse = dir.multiplyScalar(strength);
        if (socket) socket.emit("throwPlayer", { grabbedId: heldPlayerId, vx: impulse.x, vy: impulse.y, vz: impulse.z });
        heldPlayerId = null;
        focus.visible = false;
        sparkleGroup.visible = false;
        charging = false;
        chargeBarEl.classList.remove("visible");
        chargeFillEl.style.width = "0%";
        return;
      }
      if (!held) {
        charging = false;
        chargeBarEl.classList.remove("visible");
        chargeFillEl.style.width = "0%";
        return;
      }
      playSfx("throw");
      if (held.userData?.npc) playSfx(Math.random() < 0.5 ? "scream" : "scream2");
      const frac = getChargeFraction();
      const strength = CHARGE_MIN_STRENGTH + frac * (CHARGE_MAX_STRENGTH - CHARGE_MIN_STRENGTH);
      const dir = forwardVector().clone();
      const impulse = dir.multiplyScalar(strength);
      held.userData.vel.add(impulse);
      const objectId = dynamic.indexOf(held);
      if (objectId >= 0 && socket) socket.emit("throw", { objectId, vx: impulse.x, vy: impulse.y, vz: impulse.z });
      releaseHeldNPC();
      held = null;
      focus.visible = false;
      sparkleGroup.visible = false;
      charging = false;
      chargeBarEl.classList.remove("visible");
      chargeFillEl.style.width = "0%";
    }

    function releaseTelekineticJump() {
      if (!chargingJump) return;
      const frac = getChargeFraction();
      const strength = TELEJUMP_MIN + frac * (TELEJUMP_MAX - TELEJUMP_MIN);
      const flatForward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
      velY = strength * 0.5;
      grounded = false;
      launchVel.copy(flatForward).multiplyScalar(strength * 0.9);
      chargingJump = false;
      charging = false;
      chargeBarEl.classList.remove("visible");
      chargeFillEl.style.width = "0%";
    }

    document.addEventListener("mousedown", (e) => {
      if (!pointerLocked) return;

      if (e.button === 0) { // left click — start charging throw or telekinetic jump
        if (held || heldPlayerId) {
          charging = true;
          chargeStart = performance.now();
          chargeBarEl.classList.add("visible");
        } else if (pitch >= TELEJUMP_PITCH_THRESHOLD) {
          chargingJump = true;
          charging = true;
          chargeStart = performance.now();
          chargeJumpT = 0;
          chargeBarEl.classList.add("visible");
        }
      }
      if (e.button === 2) { // right click drop
        if (heldPlayerId) {
          if (socket) socket.emit("releasePlayer");
          heldPlayerId = null;
          focus.visible = false;
          sparkleGroup.visible = false;
          charging = false;
          chargeBarEl.classList.remove("visible");
          chargeFillEl.style.width = "0%";
        } else if (held) {
          const objectId = dynamic.indexOf(held);
          if (objectId >= 0 && socket) socket.emit("drop", objectId);
          releaseHeldNPC();
          held = null;
          focus.visible = false;
          sparkleGroup.visible = false;
          charging = false;
          chargeBarEl.classList.remove("visible");
          chargeFillEl.style.width = "0%";
        }
      }
    });

    document.addEventListener("mouseup", (e) => {
      if (!pointerLocked) return;
      if (e.button === 0 && charging) {
        if (chargingJump) releaseTelekineticJump();
        else releaseThrow();
      }
    });

    document.addEventListener("contextmenu", (e) => e.preventDefault());

    document.addEventListener("wheel", (e) => {
      if (!pointerLocked) return;
      if (held || heldPlayerId) {
        holdDistance += (e.deltaY < 0 ? 1 : -1) * 1.2;
        holdDistance = Math.max(2, Math.min(40, holdDistance));
        scrollFeedback = 0.3;
      } else {
        holdDistance += (e.deltaY > 0 ? 1 : -1) * 0.9;
        holdDistance = Math.max(2.2, Math.min(18, holdDistance));
      }
    }, { passive: true });

    // Hold E to grab
    function updateHolding() {
      holding = keys.has("KeyE");
      if (!holding) {
        if (heldPlayerId && socket) socket.emit("releasePlayer");
        heldPlayerId = null;
        return;
      }

      if (!held && !heldPlayerId) {
        const hit = getAimHit();
        if (hit && hit.object) {
          const obj = hit.object;
          const otherId = obj.userData.otherPlayerId;
          if (otherId && socket) {
            heldPlayerId = otherId;
            socket.emit("grabPlayer", otherId);
            const p = otherPlayers.get(otherId);
            if (p) {
              holdDistance = Math.max(2, Math.min(40, new THREE.Vector3(p.x - duck.position.x, 0, p.z - duck.position.z).length()));
              holdHeight = p.y + 2;
            }
            focus.visible = true;
            playSfx("grab");
          } else {
            const npc = obj.userData.npc;
            if (npc) {
              held = npc.mesh;
              held.userData.vel = npc.vel;
              held.userData.size = DUCK_SIZE.clone();
              held.userData.mass = 1.5;
              held.userData.npc = npc;
              npc.grabbed = true;
            } else {
              held = obj;
            }
            const objectId = dynamic.indexOf(held);
            if (objectId >= 0 && socket) socket.emit("grab", objectId);
            focus.visible = true;
            const grabPos = held.parent === scene ? held.position : held.getWorldPosition(new THREE.Vector3());
            const grabDist = grabPos.clone().sub(duck.position).length();
            holdDistance = Math.max(2, Math.min(40, grabDist));
            holdHeight = grabPos.y + 5;
            held.userData.vel.y += 2.5;
            playSfx("grab");
          }
        }
      }
    }

    // Pull held object toward target point in front of camera
    function applyTelekinesis(dt) {
      const flatForward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
      const target = duck.position.clone().add(flatForward.multiplyScalar(holdDistance));
      target.y = holdHeight;

      if (heldPlayerId) {
        focus.position.copy(target).add(new THREE.Vector3(0, 0.6, 0));
        return;
      }
      if (!held) return;

      // Rigid follow: lerp position directly, kill velocity
      const lerp = 1 - Math.pow(0.001, dt); // ~0.93 at 60fps — snappy but smooth
      held.position.lerp(target, lerp);
      held.userData.vel.set(0, 0, 0);

      focus.position.copy(held.position).add(new THREE.Vector3(0, held.userData.size.y * 0.45, 0));
    }

    // ---------------------------
    // Simple dynamic collision (floor + building AABBs)
    // ---------------------------
    function meshAABB(mesh) {
      const half = mesh.userData.size.clone().multiplyScalar(0.5);
      const min = mesh.position.clone().sub(half);
      const max = mesh.position.clone().add(half);
      return new THREE.Box3(min, max);
    }

    function resolveDynamicCollisions(m) {
      // Floor
      const halfY = m.userData.size.y * 0.5;
      if (m.position.y - halfY < FLOOR_Y) {
        m.position.y = FLOOR_Y + halfY;
        if (m.userData.vel.y < 0) m.userData.vel.y *= -0.35;
        // friction
        m.userData.vel.x *= 0.8;
        m.userData.vel.z *= 0.8;
      }

      // Against static colliders (buildings)
      const box = meshAABB(m);
      for (const c of colliders) {
        if (!aabbIntersects(box, c)) continue;

        // Resolve minimal overlap axis: X/Z/Y
        const overlapX = Math.min(box.max.x - c.min.x, c.max.x - box.min.x);
        const overlapY = Math.min(box.max.y - c.min.y, c.max.y - box.min.y);
        const overlapZ = Math.min(box.max.z - c.min.z, c.max.z - box.min.z);

        // choose smallest
        if (overlapY <= overlapX && overlapY <= overlapZ) {
          // push up/down
          if (m.position.y > (c.min.y + c.max.y) * 0.5) m.position.y += overlapY + 0.01;
          else m.position.y -= overlapY + 0.01;
          m.userData.vel.y *= -0.25;
        } else if (overlapX <= overlapZ) {
          if (m.position.x > (c.min.x + c.max.x) * 0.5) m.position.x += overlapX + 0.01;
          else m.position.x -= overlapX + 0.01;
          m.userData.vel.x *= -0.3;
        } else {
          if (m.position.z > (c.min.z + c.max.z) * 0.5) m.position.z += overlapZ + 0.01;
          else m.position.z -= overlapZ + 0.01;
          m.userData.vel.z *= -0.3;
        }

        // update box after resolve
        const b2 = meshAABB(m);
        box.min.copy(b2.min);
        box.max.copy(b2.max);
      }
    }

    // ---------------------------
    // Building destruction (partial — shatters near impact)
    // ---------------------------
    const BREAK_SPEED = 55; // ~75% charge throw needed to break
    const BLAST_RADIUS = 8; // how far from impact blocks shatter
    const BLOCK_SIZE = 2.5; // grid subdivision size
    const MAX_DEBRIS = 80;  // cap to prevent lag
    const sharedDebrisGeo = new THREE.BoxGeometry(1, 1, 1);

    function debrisCount() {
      return dynamic.filter((m) => m.userData?.isDebris).length;
    }

    function removeSettledDebris() {
      if (debrisCount() <= MAX_DEBRIS) return;
      const toRemove = [];
      for (const m of dynamic) {
        if (!m.userData?.isDebris) continue;
        const halfY = m.userData.size?.y * 0.5 ?? 0.5;
        const settled = m.userData.vel.length() < 1.5 && m.position.y - halfY < 1.5;
        if (settled) toRemove.push(m);
        if (debrisCount() - toRemove.length <= MAX_DEBRIS) break;
      }
      for (const m of toRemove) {
        scene.remove(m);
        // Don't dispose geometry — it's shared
        const di = dynamic.indexOf(m);
        if (di >= 0) dynamic.splice(di, 1);
        const ii = interactables.indexOf(m);
        if (ii >= 0) interactables.splice(ii, 1);
      }
    }

    function shatterBuilding(bldg, impactPos, impactVel) {
      playSfx("shatter");
      const mesh = bldg.mesh;
      const box = bldg.box;
      const mat = mesh.material;

      const bw = box.max.x - box.min.x;
      const bh = box.max.y - box.min.y;
      const bd = box.max.z - box.min.z;

      // Remove original mesh + collider
      scene.remove(mesh);
      if (mesh.geometry) mesh.geometry.dispose();
      const ci = colliders.indexOf(box);
      if (ci >= 0) colliders.splice(ci, 1);
      bldg.destroyed = true;

      // Subdivide into grid blocks
      const nx = Math.max(1, Math.ceil(bw / BLOCK_SIZE));
      const ny = Math.max(1, Math.ceil(bh / BLOCK_SIZE));
      const nz = Math.max(1, Math.ceil(bd / BLOCK_SIZE));
      const cellW = bw / nx;
      const cellH = bh / ny;
      const cellD = bd / nz;

      const debrisMat = new THREE.MeshStandardMaterial({
        color: mat.color.clone(),
        roughness: 0.85,
      });

      for (let ix = 0; ix < nx; ix++) {
        for (let iy = 0; iy < ny; iy++) {
          for (let iz = 0; iz < nz; iz++) {
            const cx = box.min.x + (ix + 0.5) * cellW;
            const cy = box.min.y + (iy + 0.5) * cellH;
            const cz = box.min.z + (iz + 0.5) * cellD;

            const dist = Math.sqrt(
              (cx - impactPos.x) ** 2 +
              (cy - impactPos.y) ** 2 +
              (cz - impactPos.z) ** 2
            );

            if (dist < BLAST_RADIUS) {
              // --- Dynamic debris: shatter this block ---
              const atLimit = debrisCount() >= MAX_DEBRIS;
              if (atLimit) continue; // skip spawning when at cap
              const pieces = debrisCount() > MAX_DEBRIS * 0.7 ? 1 : 2 + Math.floor(Math.random() * 2);
              for (let p = 0; p < pieces; p++) {
                const sw = rand(0.2, cellW * 0.5);
                const sh = rand(0.2, cellH * 0.5);
                const sd = rand(0.2, cellD * 0.5);

                const debris = new THREE.Mesh(sharedDebrisGeo, debrisMat);
                debris.scale.set(sw, sh, sd);
                debris.castShadow = false;
                debris.receiveShadow = false;
                debris.position.set(
                  cx + rand(-cellW * 0.3, cellW * 0.3),
                  cy + rand(-cellH * 0.3, cellH * 0.3),
                  cz + rand(-cellD * 0.3, cellD * 0.3)
                );
                scene.add(debris);

                // Explode away from impact
                const dirX = cx - impactPos.x;
                const dirY = cy - impactPos.y;
                const dirZ = cz - impactPos.z;
                const force = Math.max(0.5, 1 - dist / BLAST_RADIUS);
                const spread = 6 * force;
                debris.userData.vel = new THREE.Vector3(
                  dirX * 2 * force + impactVel.x * 0.2 + rand(-spread, spread),
                  dirY * 1.5 * force + rand(2, 8) * force,
                  dirZ * 2 * force + impactVel.z * 0.2 + rand(-spread, spread)
                );
                debris.userData.mass = rand(0.5, 2);
                debris.userData.size = new THREE.Vector3(sw, sh, sd);
                debris.userData.isDebris = true;
                dynamic.push(debris);
                interactables.push(debris);
              }
            } else {
              // --- Static remnant: keep this block as part of the building ---
              const block = new THREE.Mesh(
                new THREE.BoxGeometry(cellW * 0.98, cellH * 0.98, cellD * 0.98),
                mat
              );
              block.position.set(cx, cy, cz);
              block.castShadow = true;
              block.receiveShadow = true;
              scene.add(block);
              // Register as a new breakable building
              const newBox = makeAABBFromMesh(block);
              colliders.push(newBox);
              buildings.push({ mesh: block, box: newBox, destroyed: false });
            }
          }
        }
      }
    }

    // Check if a fast-moving object should break a building
    function checkBuildingDestruction(m) {
      const speed = m.userData.vel.length();
      if (speed < BREAK_SPEED) return;

      const mBox = meshAABB(m);
      for (const bldg of buildings) {
        if (bldg.destroyed) continue;
        if (!aabbIntersects(mBox, bldg.box)) continue;
        shatterBuilding(bldg, m.position.clone(), m.userData.vel.clone());
        m.userData.vel.multiplyScalar(0.4);
        return;
      }
    }

    // ---------------------------
    // NPC Ducks
    // ---------------------------
    const NPC_COUNT = 20;
    const npcDucks = [];
    const npcColors = [0xf5d547, 0x7dd3fc, 0xa3e635, 0xfb7185, 0xc084fc, 0xfbbf24, 0x67e8f9, 0xf472b6];

    function createNPCDuck() {
      const color = npcColors[(Math.random() * npcColors.length) | 0];
      const group = new THREE.Group();
      const model = cloneDuckModel(color);
      if (model) group.add(model);
      // Same scale as player — no extra scaling; use shared duck hitbox

      const x = rand(-80, 80);
      const z = rand(-80, 80);
      group.position.set(x, DUCK_HALF.y, z);
      scene.add(group);

      const npc = {
        mesh: group,
        vel: new THREE.Vector3(),
        targetDir: new THREE.Vector3(rand(-1, 1), 0, rand(-1, 1)).normalize(),
        changeDirTimer: rand(1, 4),
        speed: rand(2.5, 5),
        paused: false,
        pauseTimer: 0,
        grabbed: false,
        hitboxSize: DUCK_SIZE.clone(), // same as player / other players
      };

      // Grab detection: use hitbox-sized invisible box so grab matches collision
      const grabBox = makeGrabBox({
        npc,
        size: DUCK_SIZE.clone(),
        mass: 1.5,
        vel: npc.vel,
      });
      group.add(grabBox);
      interactables.push(grabBox);

      return npc;
    }

    for (let i = 0; i < NPC_COUNT; i++) {
      npcDucks.push(createNPCDuck());
    }

    function npcAABB(npc, pos) {
      const half = npc.hitboxSize.clone().multiplyScalar(0.5);
      const center = pos !== undefined ? pos : npc.mesh.position;
      return new THREE.Box3(center.clone().sub(half), center.clone().add(half));
    }

    function updateNPCs(dt) {
      for (const npc of npcDucks) {
        // --- Grabbed: telekinesis controls position ---
        if (npc.grabbed) {
          npc.mesh.rotation.z = Math.sin(performance.now() * 0.01) * 0.3;
          continue;
        }

        // --- Airborne / thrown: apply physics ---
        if (npc.mesh.position.y > 1.2 || npc.vel.lengthSq() > 4) {
          npc.vel.y -= GRAVITY * dt;
          npc.vel.multiplyScalar(0.995);
          npc.mesh.position.addScaledVector(npc.vel, dt);

          // Check building destruction — NPCs can smash buildings too
          const npcSpeed = npc.vel.length();
          if (npcSpeed >= BREAK_SPEED) {
            const npcBox = npcAABB(npc);
            for (const bldg of buildings) {
              if (bldg.destroyed) continue;
              if (!aabbIntersects(npcBox, bldg.box)) continue;
              shatterBuilding(bldg, npc.mesh.position.clone(), npc.vel.clone());
              npc.vel.multiplyScalar(0.4);
              break;
            }
          }

          // Bounce off buildings (non-destructive hits)
          const npcHitBox = npcAABB(npc);
          for (const c of colliders) {
            if (!aabbIntersects(npcHitBox, c)) continue;
            const overlapX = Math.min(npcHitBox.max.x - c.min.x, c.max.x - npcHitBox.min.x);
            const overlapZ = Math.min(npcHitBox.max.z - c.min.z, c.max.z - npcHitBox.min.z);
            if (overlapX < overlapZ) {
              if (npc.mesh.position.x > (c.min.x + c.max.x) * 0.5) npc.mesh.position.x += overlapX + 0.01;
              else npc.mesh.position.x -= overlapX + 0.01;
              npc.vel.x *= -0.4;
            } else {
              if (npc.mesh.position.z > (c.min.z + c.max.z) * 0.5) npc.mesh.position.z += overlapZ + 0.01;
              else npc.mesh.position.z -= overlapZ + 0.01;
              npc.vel.z *= -0.4;
            }
            break;
          }

          // Floor
          const npcFloorY = npc.hitboxSize.y * 0.5;
          if (npc.mesh.position.y < npcFloorY) {
            npc.mesh.position.y = npcFloorY;
            if (npc.vel.y < 0) npc.vel.y *= -0.3;
            npc.vel.x *= 0.7;
            npc.vel.z *= 0.7;
          }

          // Tumble while airborne
          npc.mesh.rotation.x += npc.vel.length() * dt * 0.5;
          npc.mesh.rotation.z += dt * 3;

          // Once settled, resume AI
          if (npc.mesh.position.y <= npcFloorY + 0.05 && npc.vel.length() < 1.5) {
            npc.vel.set(0, 0, 0);
            npc.mesh.rotation.x = 0;
            npc.mesh.rotation.z = 0;
            npc.changeDirTimer = rand(0.5, 2);
          }
          continue;
        }

        // --- Normal AI wandering ---
        npc.changeDirTimer -= dt;
        if (npc.changeDirTimer <= 0) {
          if (!npc.paused && Math.random() < 0.3) {
            npc.paused = true;
            npc.pauseTimer = rand(1, 3);
          } else {
            npc.paused = false;
            npc.targetDir.set(rand(-1, 1), 0, rand(-1, 1)).normalize();
            npc.speed = rand(2.5, 5);
          }
          npc.changeDirTimer = rand(1.5, 5);
        }

        if (npc.paused) {
          npc.pauseTimer -= dt;
          if (npc.pauseTimer <= 0) npc.paused = false;
          npc.mesh.rotation.y += Math.sin(performance.now() * 0.003) * dt * 2;
          continue;
        }

        // Move toward target direction
        const move = npc.targetDir.clone().multiplyScalar(npc.speed * dt);
        const nextPos = npc.mesh.position.clone().add(move);
        nextPos.y = npc.hitboxSize.y * 0.5;

        // Collision check — bounce off buildings
        const box = npcAABB(npc, nextPos);
        let blocked = false;
        for (const c of colliders) {
          if (aabbIntersects(box, c)) {
            blocked = true;
            break;
          }
        }

        if (blocked) {
          npc.targetDir.set(rand(-1, 1), 0, rand(-1, 1)).normalize();
          npc.changeDirTimer = rand(0.5, 2);
        } else {
          npc.mesh.position.copy(nextPos);
        }

        // Keep in bounds
        if (Math.abs(npc.mesh.position.x) > 150 || Math.abs(npc.mesh.position.z) > 150) {
          npc.targetDir.set(-npc.mesh.position.x, 0, -npc.mesh.position.z).normalize();
        }

        // Face movement direction (add Math.PI to match duck model orientation)
        npc.mesh.rotation.y = Math.atan2(npc.targetDir.x, npc.targetDir.z) + Math.PI;

        // Waddle animation
        const waddle = Math.sin(performance.now() * 0.008 * npc.speed) * 0.12;
        npc.mesh.rotation.z = waddle;
      }
    }

    // ---------------------------
    // Game loop
    // ---------------------------
    const statsEl = document.getElementById("stats");
    const clock = new THREE.Clock();
    let fpsSmoothing = 0;
    let startPos = duck.position.clone();

    function reset() {
      duck.position.copy(startPos);
      velY = 0;
      launchVel.set(0, 0, 0);
      chargingJump = false;
      releaseHeldNPC();
      held = null;
      if (heldPlayerId && socket) socket.emit("releasePlayer");
      heldPlayerId = null;
      grabbedBy = null;
      focus.visible = false;
      sparkleGroup.visible = false;

      // lightly re-scatter dynamic props
      for (const m of dynamic) {
        m.position.set(rand(-90, 90), 1.2 + rand(0, 1.2), rand(-90, 90));
        m.userData.vel.set(0, 0, 0);
      }
    }

    function step(dt) {
      // Update camera orientation from yaw/pitch
      duck.rotation.y = yaw;
      camPivot.rotation.x = pitch;

      if (grabbedBy && lastGrabbedPosition) {
        duck.position.set(lastGrabbedPosition.x, lastGrabbedPosition.y, lastGrabbedPosition.z);
      } else {
        // Input -> movement (relative to yaw)
        const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
        const right   = new THREE.Vector3(forward.z, 0, -forward.x).normalize();

        const sprint = keys.has("ShiftLeft") || keys.has("ShiftRight");
        const speed = sprint ? 14.5 : 9.5;

        let move = new THREE.Vector3();
        if (keys.has("KeyW")) move.add(forward);
        if (keys.has("KeyS")) move.sub(forward);
        if (keys.has("KeyA")) move.add(right);
        if (keys.has("KeyD")) move.sub(right);

        if (move.lengthSq() > 0) move.normalize().multiplyScalar(speed * dt);

        if ((keys.has("Space")) && grounded) {
          velY = 9.5;
          grounded = false;
        }

        velY -= GRAVITY * dt;

        let nextPos = duck.position.clone().add(move);
        nextPos.addScaledVector(launchVel, dt);
        launchVel.multiplyScalar(Math.max(0, 1 - 4.5 * dt));
        nextPos.y += velY * dt;

        if (nextPos.y < DUCK_HALF.y) {
          nextPos.y = DUCK_HALF.y;
          velY = 0;
          launchVel.multiplyScalar(0.3);
          grounded = true;
        }

        nextPos = resolvePlayerCollisions(nextPos);

        duck.position.copy(nextPos);

        // Walking waddle in 3rd person when moving (negated for coordinate convention)
        if (thirdPersonMode && duckModel != null) {
          const isMoving = move.lengthSq() > 0;
          const waddle = isMoving && grounded
            ? -Math.sin(performance.now() * 0.008 * speed) * 0.12
            : 0;
          duckModel.rotation.z = waddle;
        }
      }

      // Send position to server
      if (socket && myId) {
        socket.emit("playerUpdate", {
          x: duck.position.x, y: duck.position.y, z: duck.position.z,
          yaw, pitch, velY,
          heldId: held ? dynamic.indexOf(held) : null,
          heldPlayerId: heldPlayerId || undefined,
          holdDistance, holdHeight,
        });
      }

      // Update objects held by other players
      for (const [objectId, playerId] of objectHeldBy) {
        const p = otherPlayers.get(playerId);
        const m = dynamic[objectId];
        if (!p || !m) continue;
        const flatForward = new THREE.Vector3(-Math.sin(p.yaw), 0, -Math.cos(p.yaw)).normalize();
        const target = new THREE.Vector3(p.x, p.y, p.z).add(flatForward.multiplyScalar(p.holdDistance || 6));
        target.y = p.holdHeight ?? 5;
        m.position.lerp(target, 0.3);
        m.userData.vel.set(0, 0, 0);
      }

      // Telekinesis grab / hold
      updateHolding();
      applyTelekinesis(dt);
      updateSparkles(dt);
      updateChargeJumpParticles(dt);

      // Update charge bar
      if (charging && (held || heldPlayerId || chargingJump)) {
        const frac = getChargeFraction();
        chargeFillEl.style.width = (frac * 100).toFixed(1) + "%";
      }

      // Cleanup settled debris when over limit
      removeSettledDebris();

      // Update dynamic props
      for (let i = 0; i < dynamic.length; i++) {
        const m = dynamic[i];
        if (objectHeldBy.has(i)) continue; // held by another player
        if (m === held) continue; // position controlled by applyTelekinesis
        m.userData.vel.y -= GRAVITY * dt;
        m.userData.vel.multiplyScalar(DAMPING);
        m.position.addScaledVector(m.userData.vel, dt);
        checkBuildingDestruction(m);
        resolveDynamicCollisions(m);
      }

      // Dynamic-to-NPC collisions: blocks hit NPCs
      for (const m of dynamic) {
        const mSpeed = m.userData.vel.length();
        if (mSpeed < 2) continue; // skip slow/resting objects
        const mBox = meshAABB(m);
        for (const npc of npcDucks) {
          if (npc.grabbed) continue;
          if (held === npc.mesh) continue;
          const nBox = npcAABB(npc);
          if (!aabbIntersects(mBox, nBox)) continue;
          // Transfer momentum to the NPC
          const knockback = m.userData.vel.clone().multiplyScalar(0.8 / Math.max(0.5, npc.mesh.userData?.mass || 1.5));
          knockback.y = Math.max(knockback.y, 4 + mSpeed * 0.2); // always launch upward
          npc.vel.add(knockback);
          // Reduce the object's velocity
          m.userData.vel.multiplyScalar(0.3);
          break; // one NPC per object per frame
        }
      }

      // NPC-to-NPC collisions: thrown NPCs hit other NPCs
      for (const a of npcDucks) {
        if (a.vel.length() < 5) continue;
        const aBox = npcAABB(a);
        for (const b of npcDucks) {
          if (a === b || b.grabbed) continue;
          const bBox = npcAABB(b);
          if (!aabbIntersects(aBox, bBox)) continue;
          const knock = a.vel.clone().multiplyScalar(0.6);
          knock.y = Math.max(knock.y, 3 + a.vel.length() * 0.15);
          b.vel.add(knock);
          a.vel.multiplyScalar(0.4);
          break;
        }
      }

      // PVP: thrown objects hit other players
      for (const m of dynamic) {
        const mSpeed = m.userData.vel.length();
        if (mSpeed < 2) continue;
        const mBox = meshAABB(m);
        for (const [pid, p] of otherPlayers) {
          if (pid === myId || (heldPlayerId === pid)) continue;
          const oBox = otherPlayerAABB(new THREE.Vector3(p.x, p.y, p.z));
          if (!aabbIntersects(mBox, oBox)) continue;
          const knock = m.userData.vel.clone().multiplyScalar(0.7);
          knock.y = Math.max(knock.y, 4 + mSpeed * 0.15);
          if (socket) socket.emit("hitPlayer", { targetId: pid, vx: knock.x, vy: knock.y, vz: knock.z });
          m.userData.vel.multiplyScalar(0.25);
          break;
        }
      }

      // PVP: thrown NPCs hit other players
      for (const npc of npcDucks) {
        if (npc.vel.length() < 5) continue;
        const nBox = npcAABB(npc);
        for (const [pid, p] of otherPlayers) {
          if (pid === myId || (heldPlayerId === pid)) continue;
          const oBox = otherPlayerAABB(new THREE.Vector3(p.x, p.y, p.z));
          if (!aabbIntersects(nBox, oBox)) continue;
          const knock = npc.vel.clone().multiplyScalar(0.6);
          knock.y = Math.max(knock.y, 5 + npc.vel.length() * 0.2);
          if (socket) socket.emit("hitPlayer", { targetId: pid, vx: knock.x, vy: knock.y, vz: knock.z });
          npc.vel.multiplyScalar(0.35);
          break;
        }
      }

      // NPC ducks
      updateNPCs(dt);

      // Reset hotkey
      if (keys.has("KeyR")) reset();

      // HUD (only when online)
      if (socket && myId) {
        const fps = 1 / Math.max(1e-6, dt);
        fpsSmoothing = fpsSmoothing ? (fpsSmoothing * 0.92 + fps * 0.08) : fps;
        const playerCount = otherPlayers.size + 1;
        statsEl.textContent =
          `Objects: ${interactables.length} • Held: ${held ? "yes" : "none"} • Players: ${playerCount} • FPS: ${fpsSmoothing.toFixed(0)}`;
      }
    }

    function animate() {
      const dt = Math.min(0.033, clock.getDelta());
      if (pointerLocked) step(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // ---------------------------
    // Resize
    // ---------------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initial hint behavior
    document.addEventListener("click", () => {
      const hint = document.getElementById("hint");
      hint.style.opacity = "0.75";
      setTimeout(() => hint.style.opacity = "0.95", 500);
    });

    // Put player in a nice start spot
    reset();
  </script>
</body>
</html>
